# 分库分表之后，id 主键如何处理？
这是分库分表之后你必然要面对的一个问题，就是 id 咋生成？因为要是分成多个表之后，每个表都是从 1 开始累加，那肯定不对啊，需要一个全局唯一的 id 来支持。
    
## 基于数据库的实现方案

### 数据库自增 id
在单个节点数据库里建一张表，每次需要主键id时往该库的表中插入一条没有业务含义的数据，然后获得一个数据库自增id，拿到id后再往对应的分库表中进行写入。    

这个方案的好处就是方便简单；缺点就是单库生成自增 id，要是高并发的话，就会有瓶颈的；如果要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前 id 最大值，然后自己递增几个 id，一次性返回一批 id，然后再把当前最大 id 值修改成递增几个 id 之后的一个值；但是无论如何都是基于单个数据库。    

适合的场景：分库分表的原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你并发不高，但是数据量太大导致的分库分表扩容，可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库表生成自增主键即可。    


### 设置数据库 sequence 或者表自增字段步长
可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。    

比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。    
![sequence step](../../../../resources/images/database/database-id-sequence-step.png)   
**适合的场景**：这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，不好扩展。

## UUID
优点是本地生成，不需要基于数据库；    
缺点就是，UUID 太长了、占用空间大，作为主键性能太差了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。    

**适合的场景**：如果你是要随机生成个文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID 的。    
`UUID.randomUUID().toString().replace(“-”, “”)`    


## 基于系统当前时间
获取系统当前时间，问题是，高并发时会有重复的情况，这个是肯定不合适的。   

**适合的场景**：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id。你可以将别的业务字段值（比如：服务器id）跟当前时间拼接起来，组成一个全局唯一的编号。

## 基于redis incryby
基于redis的incryby(key, 1)实现，返回值为incry之前的值，可以作为全局唯一的id。

## snowflake 算法
snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。

