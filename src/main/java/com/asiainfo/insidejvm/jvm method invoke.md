# 方法调用
当java虚拟机调用一个类方法时，它会基于对象引用的类型（编译时可知）来选择所调用的方法；相反，当虚拟机调用一个实例方法时，它会基于对象实际的类（只能在运行时得知）来选择所调用的方法。
    
最初，所有的调用指令都指向一个包含符号引用的常量池入口。当java虚拟机遇到一条调用指令时，如果还没有解析符号引用，那么虚拟机把符号引用的解析作为执行指令调用执行过程的一部分。一旦解析了一个方法后，java虚拟机就准备调用它；如果这个方法是一个实例方法，它必须在一个对象中被调用；对实例方法的调用，虚拟机需要在栈里存在一个对象引用objectref(this)；如果方法需要参数，那么虚拟机还需要在栈中存入该方法所需要的调用参数(args)。如果这个方法是一个类方法，虚拟机只需要栈中存入调用参数(args)。objectref和args必须在调用指令执行前，被其他指令压入所调用方法的操作数栈。
    
虚拟机为每一个调用的java方法（非本地方法）建立一个新的栈帧。栈帧包括：为方法的局部变量所预留的空间、该方法的操作数栈以及特定虚拟机实现需要的其他所有信息。局部变量表和操作数栈的大小在编译时计算出来，并放置到class文件中去。虚拟机借此可以了解方法的栈帧需要多少内存；当它调用一个方法时，它为该方法创建恰当大小的栈帧，再将新的栈帧压入java栈。
    
处理实例方法时，虚拟机把所调用方法栈帧中的操作数栈中弹出objectref和args。虚拟机把objectref作为局部变量slot 0放到新的栈帧中，把所有的args作为局部变量slot 1、2、3 ... , objectref的值是隐式传递给所有实例方法的this指针。对于类方法，虚拟机只弹出参数，并将它们放到局部变量的slot 0、1、2 ..., 然后虚拟机把新的栈帧作为当前栈帧，并将PC寄存器（程序计数器）指向方法的第一条指令。
    

# 解析调用
所有方法调用中的目标方法在class文件中都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一可确定的调用版本，并且这个方法的调用版本是运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析调用。
    
在Java语言中，符合“编译期可知，运行期不可变”这个要求的方法有静态方法和私有方法两大类，前者与类型直接相关联，后者在外部不可被访问，这两种方法都不可能通过继承或者别的方式重写出其它版本，因此它们都适合在类加载阶段进行静态解析。
    
在JVM中有5条调用方法的字节码指令:
- invokestatic: 调用静态方法

- invokespecial: 调用实例构造器<init>()方法，私有方法和父类方法。

- invokevirtual: 调用虚方法。

- invokeinterface: 调用接口方法，会在运行时再确定一个实现此接口的对象。

- invokedynamic: 先在运行时动态解析出调用点限定符所引用的的方法，然后再执行此方法
    
通过invokestatic和invokespecial指令调用的方法，可以在解析阶段确定调用版本，这些方法叫做非虚方法。
    
剩下三个字节码指令调用的方法叫做虚方法（被final关键字修饰的方法，虽然使用invokevirtual指令调用，由于它无法被覆盖重写，所以也是一种非虚方法）。
    

# 重载方法的选择
Java虚拟机识别方法的关键在于类名/方法名/方法描述符(method descriptor)。
    
重载方法在编译过程中即可完成识别，具体到每一个方法调用，Java编译器会根据所传入参数的声明类型来选取重载方法。
1. 不考虑对基本类型自动装拆箱(auto-boxing / unboxing), 以及可变长参数的情况下选取重载方法;
2. 如果1中未找到适配的方法, 则允许自动装拆箱, 但不允许可变长参数的情况下选取重载方法;
3. 如果2中未找到适配的方法, 则在允许自动装拆箱以及可变长参数的情况下选取重载方法。
    

# 虚方法调用
- 所有非私有实例方法被调用 -> invokevirtual指令.

- 接口方法调用 -> invokeinterface指令. 
    
动态绑定：Java虚拟机需要根据调用者的实际类型确定虚方法调用的目标方法，这个过程被称为动态绑定。相对于静态绑定的非虚方法调用，虚方法调用更加耗时。
    
静态绑定： 静态绑定包括用于调用静态方法的invokestatic指令和用于调用构造器/私有实例方法/超类实例方法的invokespecial指令。
    
如果虚方法调用invokevirtual指向一个标记为final的方法，那么Java虚拟机也可以静态绑定该虚方法调用的目标方法。
    

# 方法表
Java虚拟机采用了一种用空间换时间的策略来实现动态绑定，它为每个类生成一张方法表，用以快速定位目标方法。
    
方法表在类加载的连接阶段进行初始化，存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那么子类的虚方法表中该方法的入口地址和父类保持一致，都指向父类的实现入口；如果子类中重写了这个方法，子类方法表中的地址会替换为子类实现版本的入口地址。
   
方法表本质上是一个数组，每个数组元素指向一个当前类及其父类中非私有的实例方法。
    
方法表满足两个特质:
1. 子类方法表中包含父类方法表中的所有方法
2. 子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同
    
静态绑定的方法调用: 实际引用 -> 具体的目标方法
    
动态绑定的方法调用: 实际引用 -> 方法表的索引值
    
动态绑定的过程：虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。
    
动态绑定的优化：内联缓存(inlining cache)和方法内联(method inlining)。
    

# 内联缓存(inlining cache)
内联缓存是一种加快动态绑定的优化技术，它能够缓存虚方法调用中调用者的动态类型以及该类型所对应的目标方法；后续执行中，优先使用缓存，缓存中没有找到则使用基于方法表的动态绑定。
    

# 方法内联(method inlining)
如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身。
    

# 从方法中返回
每一种操作码对应一种返回的数据类型，它们都没有操作数，如果有返回值，必须被放置在操作数栈中。返回值从操作数栈中弹出，然后被压入调用方法（调用代码所在的方法）的栈帧的操作数栈中。弹出当前栈帧，调用方法的栈帧成为当前栈帧；程序计数器被重置，指向紧随调用返回方法那条指令的下一条指令。
    



# 泛型和协变返回值类型
Java 5增加了泛型和covariant return type（协变返回值类型）。这两种功能都是通过“bridge method”的方式实现的。
    
所谓“bridge method”，是Java源码编译器可以自动生成的、用于填补Java源码语义与JVM所需要的语义之间的差异的“桥接方法”。
    
以Java 5的泛型为例：
    
```
class Base<T> { public T foo() { return null; } } 
class Derived extends Base<String> { 
    @Override public String foo() { return null; } 
} 
```
    
由于Java使用擦除法实现泛型，从JVM的角度看，Base类的foo()方法的method descriptor是这样的：`foo:()Ljava/lang/Object;` 可见泛型参数T被擦除为Object了。
    
而Derived类在继承Base时给泛型参数T提供了一个实际类型java.lang.String，所以Java语言的语义允许返回String的Derived.foo()去@Override返回T的Base.foo()。但从JVM的角度看，Derived类的foo()方法的method descriptor是：`foo:()Ljava/lang/String;` 跟Base.foo()并不完全一致，因而从JVM的角度看它们互为overload而无法构成@Override关系。
    
为了填补这个语义差异，同时为了避免要修改JVM来支持新的泛型功能，Java源码编译器就生成了一个bridge method，使实际的Derived.class里看起来是这样：
    
```
class Derived extends Base<String> {
    // compiler-generated bridge method 
    public Object foo() { 
        return this.foo(); 
        // Java bytecodes: 
        // aload_0
        // invokevirtual Derived.foo:()Ljava/lang/String;
        // areturn 
    } 
    public String foo() { return null; } 
}
```
    
编译器生成的bridge method的method descriptor就跟Base.foo()的完全匹配了，这样JVM就会认为这个bridge method与Base.foo()构成override关系；而这个bridge method里面会调用源码里写的String版Derived.foo()，这样就实现了Java语言层面的语义。
    

