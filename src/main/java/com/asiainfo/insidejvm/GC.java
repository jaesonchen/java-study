package com.asiainfo.insidejvm;

/**
 * HotSpot VM内存及垃圾回收机制：程序计数器、虚拟机栈、本地方法栈、堆区、方法区
 *   其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，
 *   就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。
 * 1. 堆：所有的对象实例与数组，GC堆，分为新生代与老年代
 * 2. 栈：栈帧包含局部变量表（基本数据类型 8种、对象引用类型）、操作数栈、动态链接、方法出口
 * 3. 方法区：类信息、常量、静态变量、即时编译器编译后的代码等数据，也称为永久代
 * 4. TLAB：本地线程分配缓冲，线程分配内存，先用TLAB分配，用完重新分配新的TLAB
 * 5. Mark Word：对象头：对象自身的运行时数据，哈希码，GC分代年龄，锁状态，持有的锁，偏向线程ID，偏向时间戳
 * HotSpot采用直接指针访问，栈中直接指向对象的地址，对象移动时，需要改变栈中的reference
 * 
 * 
 * Hotspot VM提供的垃圾回收器是一个分代垃圾回收器（Generational GC）-将内存划分为不同的阶段，也就是说，不同的生命周期的对象放置在不同的地址池中。
 *   这种分代方式可以减少垃圾回收的停顿时间以及大范围对象的回收成本。Hotspot VM将其堆空间分为三个分代空间：
 * 1. 年轻代（Young Generation）
 *  a. Java应用在分配Java对象时，这些对象会被分配到年轻代堆空间中去
 *  b. 这个空间大多是小对象并且会被频繁回收
 *  c. 由于年轻代堆空间的垃圾回收会很频繁，因此其垃圾回收算法会更加重视回收效率
 * 2. 年老代（Old Generationn）
 *  a. 年轻代堆空间的长期存活对象会转移到（也许是永久性转移）年老代堆空间
 *  b. 这个堆空间通常比年轻代的堆空间大，并且其空间增长速度较缓
 *  c. 由于大部分JVM堆空间都分配给了年老代，因此其垃圾回收算法需要更节省空间，此算法需要能够处理低垃圾密度的堆空间
 * 3. 持久代（Permanent Generation）
 *     存放VM和Java类型的元数据（metadata），以及intern字符串和类的静态变量(intern字符串池 jdk7后移到堆中，不在perm区)
 *     
 * 
 *  次收集（Minor GC）和全收集（Full GC）
 *  当这三个分代的堆空间比较紧张或者没有足够的空间来为新对象分配时，垃圾回收机制就会起作用。 有两种类型的垃圾回收方式：次收集和全收集。
 *  当年轻代堆空间满了的时候，会触发次收集（Minor GC）将还存活的对象移到年老代堆空间。
 *  当年老代堆空间满了的时候，会触发一个覆盖全范围的对象堆的全收集（Full GC）。
 *  次收集（Minor GC）
 *  当年轻代堆空间紧张时会被触发，相对于全收集而言，收集间隔较短
 *  全收集（Full GC）
 *  当老年代或者持久代堆空间满了，会触发全收集操作，可以使用System.gc()方法来显式的启动全收集，全收集一般根据堆大小的不同，需要的时间不尽相同，但一般会比较长。
 * 
 * 
 *  判断对象是否存活一般有两种方式：
 * a. 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，但无法解决对象相互循环引用的问题。
 * b. 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。
 * 
 * GC Roots：在Java语言中，可作为GC Roots的对象包括下面几种：
 * a. 虚拟机栈中引用的对象（栈帧中的本地变量表）；
 * b. 方法区中类静态属性引用的对象；
 * c. 方法区中常量引用的对象；
 * d. 本地方法栈中JNI（Native方法）引用的对象。
 * 
 *  方法区如何判断是否需要回收：
 * a. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
 * b. 加载该类的ClassLoader已经被回收；
 * c. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
 * 
 * 
 *  垃圾回收算法
 * a. 标记清除算法 Mark-sweep：存在效率问题与空间问题（产生大量不连续的内存碎片）
 * b. 复制算法（Copying）：应用十分广泛，将内存分为一块较大的Eden和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。
 *       回收时，将Eden与Survivor复制到另一块Survivor。默认Eden与Survivor的比例是8:1。 
 * c. 标记整理算法（Mark-Compact）：适用于老年代，将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
 * d. 分代收集算法：分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。
 *      一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。
 *      老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。
 * 
 * 
 * CMS & G1
 * CMS(Concurrent Mark Sweep)：以获取最短回收停顿时间为目标的收集器，基于并发“标记-清理”实现，过程：
 *  1、初始标记：独占CPC(STW stop the world)，仅标记GC roots能直接关联的对象
 *  2、并发标记：可以和用户线程并行执行，标记所有可达对象(GC Roots Tracing)
 *  3、重新标记：独占CPU(STW)，对并发标记阶段用户线程运行而导致标记产生变动的那一部分对象进行标记修正
 *  4、并发清理：可以和用户线程并行执行，清理垃圾
 * 
 * CMS是一个优秀的垃圾回收器，但是他也有不少缺点：
 * 1. CMS没有办法处理浮动垃圾（就是在初始标记之后产生的垃圾），在最后一步并发清理过程中，用户线程执行也会产生垃圾，但是这部分垃圾是在标记之后，所以只有等到下一次gc的时候清理掉
 * 2. 他会占用大量的CPU资源，在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢
 * 3. CMS使用“标记-清理”法会产生大量的空间碎片，当碎片过多，往往会出现老年代还有很大的空间但无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC，
 *     当发生FullGC时会使用Serial Old回收器来处理碎片空间
 * 4. 他在回收垃圾时，由于是并行的收集，所以需要的空间比较大
 * 
 * CMS 出现FullGC的原因：
 * 1、年轻带晋升到老年带没有足够的连续空间，很有可能是内存碎片导致的
 * 2、在并发过程中JVM觉得在并发过程结束之前堆就会满，需要提前触发FullGC
 * 
 * 
 * G1 GC，全称Garbage-FirstGarbage Collector，通过-XX:+UseG1GC参数来启用，在JDK 7u4版本发行时被正式推出。
 * G1的初衷就是要避免Full GC的出现，G1将整个java堆划分为多个大小想等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离了，
 *   它们都是一部分Region（不需要连续）的集合。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），
 *   在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，
 *   保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。 由于这种方式的侧重点在于处理垃圾最多的区间，所以我们给G1一个名字：垃圾优先（Garbage First）。
 *  
 * G1：是一款面向服务端应用的垃圾收集器，特点：
 * 1、并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。
 *    部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。
 * 2、分代收集：分代概念在G1中依然得以保留。虽然G1可以不需要其它收集器配合就能独立管理整个GC堆，
 *   但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。
 * 3、空间整合：由于G1使用了独立区域（Region）概念，G1从整体来看是基于“标记-整理”算法实现收集，
 *   从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。
 *   收集后能够提供规整的可用内存，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
 * 4、可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，
 *   还能建立可预测的停顿时间模型，能让使用这明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
 * 
 * G1收集器如果不计算维护Remembered Set的操作，它的运作大致可划分为以下几个步骤：
 * 1、初始标记（Initial Making）
 * 2、并发标记（Concurrent Marking）
 * 3、最终标记（Final Marking）
 * 4、筛选回收（Live Data Counting and Evacuation）
 * 
 * 
 * G1中提供了三种模式垃圾回收模式，young gc、mixed gc 和 full gc.
 * young gc
 *   发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，
 *   这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。
 * 
 * mixed gc
 *   当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，
 *   除了回收整个young region，还会回收一部分的old region，这里需要注意：是一部分老年代，而不是全部老年代，
 *   可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。
 *   
 * full gc
 *    如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，
 *    会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc。
 * 
 * 
 */
public class GC {

}
