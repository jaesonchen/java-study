





## 共享变量写回主存流程
CPU在执行内存写操作的时候，往往是先将数据写入其写缓冲器中，而不是直接写入高速缓存。一个处理器上的写缓冲器中的内容无法被其他处理器所读取，因此写线程必须确保其对volatile变量所做的更新以及其更新volatile变量前对其他普通共享变量所做的更新到达该处理器的高速缓存（而不是仍然停留在写缓冲器中）。这样，写线程的这些更新通过缓存一致性协议被其他处理器上的线程所读取才成为可能。为此，Java虚拟机（JIT编译器）会在volatile变量写操作之后插入一个StoreLoad内存屏障。这个内存屏障的其中一个作用就是将其执行处理器的写缓冲器中的当前内容写入高速缓存，并将高速缓存的内容写回主存。
    
同时，由于无效化队列（暂存无效化消息的硬件，使得修改了某个共享变量之后借以通知其他处理器其对共享变量的更新，以便其他处理器能够将其高速缓存中的相应缓存行置为无效）的存在，处理器从其高速缓存中读取到的共享变量值可能是过时的。因此，为了确保读线程能够读取到写线程对共享变量所做的更新（包括volatile变量），读线程的执行处理器必须在读取volatile变量前确保无效化队列中内容被应用到该处理器的高速缓存中，即根据无效化队列中的内容将该处理器中相应的缓存行设置为无效，从而使写线程对共享变量所做的更新能够被反映到该处理器的高速缓存上。
    
若对声明了volatile的变量进行写操作，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会主存。但是，就算回到主存，还要保证其他处理器的缓存是一致的。每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是否过期了，当处理器发现自己缓存行对应的内存地址被修改时，就会设置当前缓存行为无效，需要对数据进行修改的时候会重新从主存中加载。
    






对比这两张图，我们可以看到Java内存模型中每个线程的工作内存实际上就是寄存器以及高速缓存的抽象。在目前主流的多核处理器设计中，一般每个核心都会包含1个L1缓存和L2缓存，多个核心共享一个L3高速缓存。各个核心直接通过系统总线连接。系统总线包括数据总线，地址总线，控制总线，统称系统总线。


































